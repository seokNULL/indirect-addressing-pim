// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tml.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tml_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tml_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include "onnx/onnx-ml.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tml_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tml_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace onnxruntime {
namespace proto {
class MapInt64ToDouble;
class MapInt64ToDoubleDefaultTypeInternal;
extern MapInt64ToDoubleDefaultTypeInternal _MapInt64ToDouble_default_instance_;
class MapInt64ToDouble_VEntry_DoNotUse;
class MapInt64ToDouble_VEntry_DoNotUseDefaultTypeInternal;
extern MapInt64ToDouble_VEntry_DoNotUseDefaultTypeInternal _MapInt64ToDouble_VEntry_DoNotUse_default_instance_;
class MapInt64ToFloat;
class MapInt64ToFloatDefaultTypeInternal;
extern MapInt64ToFloatDefaultTypeInternal _MapInt64ToFloat_default_instance_;
class MapInt64ToFloat_VEntry_DoNotUse;
class MapInt64ToFloat_VEntry_DoNotUseDefaultTypeInternal;
extern MapInt64ToFloat_VEntry_DoNotUseDefaultTypeInternal _MapInt64ToFloat_VEntry_DoNotUse_default_instance_;
class MapInt64ToInt64;
class MapInt64ToInt64DefaultTypeInternal;
extern MapInt64ToInt64DefaultTypeInternal _MapInt64ToInt64_default_instance_;
class MapInt64ToInt64_VEntry_DoNotUse;
class MapInt64ToInt64_VEntry_DoNotUseDefaultTypeInternal;
extern MapInt64ToInt64_VEntry_DoNotUseDefaultTypeInternal _MapInt64ToInt64_VEntry_DoNotUse_default_instance_;
class MapInt64ToString;
class MapInt64ToStringDefaultTypeInternal;
extern MapInt64ToStringDefaultTypeInternal _MapInt64ToString_default_instance_;
class MapInt64ToString_VEntry_DoNotUse;
class MapInt64ToString_VEntry_DoNotUseDefaultTypeInternal;
extern MapInt64ToString_VEntry_DoNotUseDefaultTypeInternal _MapInt64ToString_VEntry_DoNotUse_default_instance_;
class MapStringToDouble;
class MapStringToDoubleDefaultTypeInternal;
extern MapStringToDoubleDefaultTypeInternal _MapStringToDouble_default_instance_;
class MapStringToDouble_VEntry_DoNotUse;
class MapStringToDouble_VEntry_DoNotUseDefaultTypeInternal;
extern MapStringToDouble_VEntry_DoNotUseDefaultTypeInternal _MapStringToDouble_VEntry_DoNotUse_default_instance_;
class MapStringToFloat;
class MapStringToFloatDefaultTypeInternal;
extern MapStringToFloatDefaultTypeInternal _MapStringToFloat_default_instance_;
class MapStringToFloat_VEntry_DoNotUse;
class MapStringToFloat_VEntry_DoNotUseDefaultTypeInternal;
extern MapStringToFloat_VEntry_DoNotUseDefaultTypeInternal _MapStringToFloat_VEntry_DoNotUse_default_instance_;
class MapStringToInt64;
class MapStringToInt64DefaultTypeInternal;
extern MapStringToInt64DefaultTypeInternal _MapStringToInt64_default_instance_;
class MapStringToInt64_VEntry_DoNotUse;
class MapStringToInt64_VEntry_DoNotUseDefaultTypeInternal;
extern MapStringToInt64_VEntry_DoNotUseDefaultTypeInternal _MapStringToInt64_VEntry_DoNotUse_default_instance_;
class MapStringToString;
class MapStringToStringDefaultTypeInternal;
extern MapStringToStringDefaultTypeInternal _MapStringToString_default_instance_;
class MapStringToString_VEntry_DoNotUse;
class MapStringToString_VEntry_DoNotUseDefaultTypeInternal;
extern MapStringToString_VEntry_DoNotUseDefaultTypeInternal _MapStringToString_VEntry_DoNotUse_default_instance_;
class TestCaseConfig;
class TestCaseConfigDefaultTypeInternal;
extern TestCaseConfigDefaultTypeInternal _TestCaseConfig_default_instance_;
class TraditionalMLData;
class TraditionalMLDataDefaultTypeInternal;
extern TraditionalMLDataDefaultTypeInternal _TraditionalMLData_default_instance_;
class VectorDouble;
class VectorDoubleDefaultTypeInternal;
extern VectorDoubleDefaultTypeInternal _VectorDouble_default_instance_;
class VectorFloat;
class VectorFloatDefaultTypeInternal;
extern VectorFloatDefaultTypeInternal _VectorFloat_default_instance_;
class VectorInt64;
class VectorInt64DefaultTypeInternal;
extern VectorInt64DefaultTypeInternal _VectorInt64_default_instance_;
class VectorMapInt64ToFloat;
class VectorMapInt64ToFloatDefaultTypeInternal;
extern VectorMapInt64ToFloatDefaultTypeInternal _VectorMapInt64ToFloat_default_instance_;
class VectorMapStringToFloat;
class VectorMapStringToFloatDefaultTypeInternal;
extern VectorMapStringToFloatDefaultTypeInternal _VectorMapStringToFloat_default_instance_;
class VectorString;
class VectorStringDefaultTypeInternal;
extern VectorStringDefaultTypeInternal _VectorString_default_instance_;
}  // namespace proto
}  // namespace onnxruntime
PROTOBUF_NAMESPACE_OPEN
template<> ::onnxruntime::proto::MapInt64ToDouble* Arena::CreateMaybeMessage<::onnxruntime::proto::MapInt64ToDouble>(Arena*);
template<> ::onnxruntime::proto::MapInt64ToDouble_VEntry_DoNotUse* Arena::CreateMaybeMessage<::onnxruntime::proto::MapInt64ToDouble_VEntry_DoNotUse>(Arena*);
template<> ::onnxruntime::proto::MapInt64ToFloat* Arena::CreateMaybeMessage<::onnxruntime::proto::MapInt64ToFloat>(Arena*);
template<> ::onnxruntime::proto::MapInt64ToFloat_VEntry_DoNotUse* Arena::CreateMaybeMessage<::onnxruntime::proto::MapInt64ToFloat_VEntry_DoNotUse>(Arena*);
template<> ::onnxruntime::proto::MapInt64ToInt64* Arena::CreateMaybeMessage<::onnxruntime::proto::MapInt64ToInt64>(Arena*);
template<> ::onnxruntime::proto::MapInt64ToInt64_VEntry_DoNotUse* Arena::CreateMaybeMessage<::onnxruntime::proto::MapInt64ToInt64_VEntry_DoNotUse>(Arena*);
template<> ::onnxruntime::proto::MapInt64ToString* Arena::CreateMaybeMessage<::onnxruntime::proto::MapInt64ToString>(Arena*);
template<> ::onnxruntime::proto::MapInt64ToString_VEntry_DoNotUse* Arena::CreateMaybeMessage<::onnxruntime::proto::MapInt64ToString_VEntry_DoNotUse>(Arena*);
template<> ::onnxruntime::proto::MapStringToDouble* Arena::CreateMaybeMessage<::onnxruntime::proto::MapStringToDouble>(Arena*);
template<> ::onnxruntime::proto::MapStringToDouble_VEntry_DoNotUse* Arena::CreateMaybeMessage<::onnxruntime::proto::MapStringToDouble_VEntry_DoNotUse>(Arena*);
template<> ::onnxruntime::proto::MapStringToFloat* Arena::CreateMaybeMessage<::onnxruntime::proto::MapStringToFloat>(Arena*);
template<> ::onnxruntime::proto::MapStringToFloat_VEntry_DoNotUse* Arena::CreateMaybeMessage<::onnxruntime::proto::MapStringToFloat_VEntry_DoNotUse>(Arena*);
template<> ::onnxruntime::proto::MapStringToInt64* Arena::CreateMaybeMessage<::onnxruntime::proto::MapStringToInt64>(Arena*);
template<> ::onnxruntime::proto::MapStringToInt64_VEntry_DoNotUse* Arena::CreateMaybeMessage<::onnxruntime::proto::MapStringToInt64_VEntry_DoNotUse>(Arena*);
template<> ::onnxruntime::proto::MapStringToString* Arena::CreateMaybeMessage<::onnxruntime::proto::MapStringToString>(Arena*);
template<> ::onnxruntime::proto::MapStringToString_VEntry_DoNotUse* Arena::CreateMaybeMessage<::onnxruntime::proto::MapStringToString_VEntry_DoNotUse>(Arena*);
template<> ::onnxruntime::proto::TestCaseConfig* Arena::CreateMaybeMessage<::onnxruntime::proto::TestCaseConfig>(Arena*);
template<> ::onnxruntime::proto::TraditionalMLData* Arena::CreateMaybeMessage<::onnxruntime::proto::TraditionalMLData>(Arena*);
template<> ::onnxruntime::proto::VectorDouble* Arena::CreateMaybeMessage<::onnxruntime::proto::VectorDouble>(Arena*);
template<> ::onnxruntime::proto::VectorFloat* Arena::CreateMaybeMessage<::onnxruntime::proto::VectorFloat>(Arena*);
template<> ::onnxruntime::proto::VectorInt64* Arena::CreateMaybeMessage<::onnxruntime::proto::VectorInt64>(Arena*);
template<> ::onnxruntime::proto::VectorMapInt64ToFloat* Arena::CreateMaybeMessage<::onnxruntime::proto::VectorMapInt64ToFloat>(Arena*);
template<> ::onnxruntime::proto::VectorMapStringToFloat* Arena::CreateMaybeMessage<::onnxruntime::proto::VectorMapStringToFloat>(Arena*);
template<> ::onnxruntime::proto::VectorString* Arena::CreateMaybeMessage<::onnxruntime::proto::VectorString>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace onnxruntime {
namespace proto {

// ===================================================================

class MapStringToString_VEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapStringToString_VEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapStringToString_VEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  MapStringToString_VEntry_DoNotUse();
  MapStringToString_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapStringToString_VEntry_DoNotUse& other);
  static const MapStringToString_VEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapStringToString_VEntry_DoNotUse*>(&_MapStringToString_VEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class MapStringToString :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.MapStringToString) */ {
 public:
  MapStringToString();
  virtual ~MapStringToString();

  MapStringToString(const MapStringToString& from);
  MapStringToString(MapStringToString&& from) noexcept
    : MapStringToString() {
    *this = ::std::move(from);
  }

  inline MapStringToString& operator=(const MapStringToString& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapStringToString& operator=(MapStringToString&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MapStringToString& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapStringToString* internal_default_instance() {
    return reinterpret_cast<const MapStringToString*>(
               &_MapStringToString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MapStringToString& a, MapStringToString& b) {
    a.Swap(&b);
  }
  inline void Swap(MapStringToString* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapStringToString* New() const final {
    return CreateMaybeMessage<MapStringToString>(nullptr);
  }

  MapStringToString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapStringToString>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MapStringToString& from);
  void MergeFrom(const MapStringToString& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapStringToString* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.MapStringToString";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // map<string, string> v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_v();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.MapStringToString)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      MapStringToString_VEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class MapStringToInt64_VEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapStringToInt64_VEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapStringToInt64_VEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    0 > SuperType;
  MapStringToInt64_VEntry_DoNotUse();
  MapStringToInt64_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapStringToInt64_VEntry_DoNotUse& other);
  static const MapStringToInt64_VEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapStringToInt64_VEntry_DoNotUse*>(&_MapStringToInt64_VEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class MapStringToInt64 :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.MapStringToInt64) */ {
 public:
  MapStringToInt64();
  virtual ~MapStringToInt64();

  MapStringToInt64(const MapStringToInt64& from);
  MapStringToInt64(MapStringToInt64&& from) noexcept
    : MapStringToInt64() {
    *this = ::std::move(from);
  }

  inline MapStringToInt64& operator=(const MapStringToInt64& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapStringToInt64& operator=(MapStringToInt64&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MapStringToInt64& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapStringToInt64* internal_default_instance() {
    return reinterpret_cast<const MapStringToInt64*>(
               &_MapStringToInt64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MapStringToInt64& a, MapStringToInt64& b) {
    a.Swap(&b);
  }
  inline void Swap(MapStringToInt64* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapStringToInt64* New() const final {
    return CreateMaybeMessage<MapStringToInt64>(nullptr);
  }

  MapStringToInt64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapStringToInt64>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MapStringToInt64& from);
  void MergeFrom(const MapStringToInt64& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapStringToInt64* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.MapStringToInt64";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // map<string, int64> v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_v();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.MapStringToInt64)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      MapStringToInt64_VEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::int64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      0 > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class MapStringToDouble_VEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapStringToDouble_VEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapStringToDouble_VEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  MapStringToDouble_VEntry_DoNotUse();
  MapStringToDouble_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapStringToDouble_VEntry_DoNotUse& other);
  static const MapStringToDouble_VEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapStringToDouble_VEntry_DoNotUse*>(&_MapStringToDouble_VEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class MapStringToDouble :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.MapStringToDouble) */ {
 public:
  MapStringToDouble();
  virtual ~MapStringToDouble();

  MapStringToDouble(const MapStringToDouble& from);
  MapStringToDouble(MapStringToDouble&& from) noexcept
    : MapStringToDouble() {
    *this = ::std::move(from);
  }

  inline MapStringToDouble& operator=(const MapStringToDouble& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapStringToDouble& operator=(MapStringToDouble&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MapStringToDouble& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapStringToDouble* internal_default_instance() {
    return reinterpret_cast<const MapStringToDouble*>(
               &_MapStringToDouble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MapStringToDouble& a, MapStringToDouble& b) {
    a.Swap(&b);
  }
  inline void Swap(MapStringToDouble* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapStringToDouble* New() const final {
    return CreateMaybeMessage<MapStringToDouble>(nullptr);
  }

  MapStringToDouble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapStringToDouble>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MapStringToDouble& from);
  void MergeFrom(const MapStringToDouble& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapStringToDouble* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.MapStringToDouble";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // map<string, double> v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_v();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.MapStringToDouble)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      MapStringToDouble_VEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
      0 > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class MapStringToFloat_VEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapStringToFloat_VEntry_DoNotUse, 
    std::string, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapStringToFloat_VEntry_DoNotUse, 
    std::string, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT,
    0 > SuperType;
  MapStringToFloat_VEntry_DoNotUse();
  MapStringToFloat_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapStringToFloat_VEntry_DoNotUse& other);
  static const MapStringToFloat_VEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapStringToFloat_VEntry_DoNotUse*>(&_MapStringToFloat_VEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class MapStringToFloat :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.MapStringToFloat) */ {
 public:
  MapStringToFloat();
  virtual ~MapStringToFloat();

  MapStringToFloat(const MapStringToFloat& from);
  MapStringToFloat(MapStringToFloat&& from) noexcept
    : MapStringToFloat() {
    *this = ::std::move(from);
  }

  inline MapStringToFloat& operator=(const MapStringToFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapStringToFloat& operator=(MapStringToFloat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MapStringToFloat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapStringToFloat* internal_default_instance() {
    return reinterpret_cast<const MapStringToFloat*>(
               &_MapStringToFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MapStringToFloat& a, MapStringToFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(MapStringToFloat* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapStringToFloat* New() const final {
    return CreateMaybeMessage<MapStringToFloat>(nullptr);
  }

  MapStringToFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapStringToFloat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MapStringToFloat& from);
  void MergeFrom(const MapStringToFloat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapStringToFloat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.MapStringToFloat";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // map<string, float> v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
      _internal_v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
      _internal_mutable_v();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.MapStringToFloat)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      MapStringToFloat_VEntry_DoNotUse,
      std::string, float,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT,
      0 > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class MapInt64ToString_VEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapInt64ToString_VEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapInt64ToString_VEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  MapInt64ToString_VEntry_DoNotUse();
  MapInt64ToString_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapInt64ToString_VEntry_DoNotUse& other);
  static const MapInt64ToString_VEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapInt64ToString_VEntry_DoNotUse*>(&_MapInt64ToString_VEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class MapInt64ToString :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.MapInt64ToString) */ {
 public:
  MapInt64ToString();
  virtual ~MapInt64ToString();

  MapInt64ToString(const MapInt64ToString& from);
  MapInt64ToString(MapInt64ToString&& from) noexcept
    : MapInt64ToString() {
    *this = ::std::move(from);
  }

  inline MapInt64ToString& operator=(const MapInt64ToString& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapInt64ToString& operator=(MapInt64ToString&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MapInt64ToString& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapInt64ToString* internal_default_instance() {
    return reinterpret_cast<const MapInt64ToString*>(
               &_MapInt64ToString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MapInt64ToString& a, MapInt64ToString& b) {
    a.Swap(&b);
  }
  inline void Swap(MapInt64ToString* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapInt64ToString* New() const final {
    return CreateMaybeMessage<MapInt64ToString>(nullptr);
  }

  MapInt64ToString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapInt64ToString>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MapInt64ToString& from);
  void MergeFrom(const MapInt64ToString& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapInt64ToString* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.MapInt64ToString";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // map<int64, string> v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, std::string >&
      _internal_v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, std::string >*
      _internal_mutable_v();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, std::string >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, std::string >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.MapInt64ToString)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      MapInt64ToString_VEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int64, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class MapInt64ToInt64_VEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapInt64ToInt64_VEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapInt64ToInt64_VEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    0 > SuperType;
  MapInt64ToInt64_VEntry_DoNotUse();
  MapInt64ToInt64_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapInt64ToInt64_VEntry_DoNotUse& other);
  static const MapInt64ToInt64_VEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapInt64ToInt64_VEntry_DoNotUse*>(&_MapInt64ToInt64_VEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class MapInt64ToInt64 :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.MapInt64ToInt64) */ {
 public:
  MapInt64ToInt64();
  virtual ~MapInt64ToInt64();

  MapInt64ToInt64(const MapInt64ToInt64& from);
  MapInt64ToInt64(MapInt64ToInt64&& from) noexcept
    : MapInt64ToInt64() {
    *this = ::std::move(from);
  }

  inline MapInt64ToInt64& operator=(const MapInt64ToInt64& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapInt64ToInt64& operator=(MapInt64ToInt64&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MapInt64ToInt64& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapInt64ToInt64* internal_default_instance() {
    return reinterpret_cast<const MapInt64ToInt64*>(
               &_MapInt64ToInt64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MapInt64ToInt64& a, MapInt64ToInt64& b) {
    a.Swap(&b);
  }
  inline void Swap(MapInt64ToInt64* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapInt64ToInt64* New() const final {
    return CreateMaybeMessage<MapInt64ToInt64>(nullptr);
  }

  MapInt64ToInt64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapInt64ToInt64>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MapInt64ToInt64& from);
  void MergeFrom(const MapInt64ToInt64& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapInt64ToInt64* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.MapInt64ToInt64";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // map<int64, int64> v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_v();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64 >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.MapInt64ToInt64)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      MapInt64ToInt64_VEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      0 > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class MapInt64ToFloat_VEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapInt64ToFloat_VEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapInt64ToFloat_VEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT,
    0 > SuperType;
  MapInt64ToFloat_VEntry_DoNotUse();
  MapInt64ToFloat_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapInt64ToFloat_VEntry_DoNotUse& other);
  static const MapInt64ToFloat_VEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapInt64ToFloat_VEntry_DoNotUse*>(&_MapInt64ToFloat_VEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class MapInt64ToFloat :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.MapInt64ToFloat) */ {
 public:
  MapInt64ToFloat();
  virtual ~MapInt64ToFloat();

  MapInt64ToFloat(const MapInt64ToFloat& from);
  MapInt64ToFloat(MapInt64ToFloat&& from) noexcept
    : MapInt64ToFloat() {
    *this = ::std::move(from);
  }

  inline MapInt64ToFloat& operator=(const MapInt64ToFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapInt64ToFloat& operator=(MapInt64ToFloat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MapInt64ToFloat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapInt64ToFloat* internal_default_instance() {
    return reinterpret_cast<const MapInt64ToFloat*>(
               &_MapInt64ToFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MapInt64ToFloat& a, MapInt64ToFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(MapInt64ToFloat* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapInt64ToFloat* New() const final {
    return CreateMaybeMessage<MapInt64ToFloat>(nullptr);
  }

  MapInt64ToFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapInt64ToFloat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MapInt64ToFloat& from);
  void MergeFrom(const MapInt64ToFloat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapInt64ToFloat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.MapInt64ToFloat";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // map<int64, float> v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, float >&
      _internal_v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, float >*
      _internal_mutable_v();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, float >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, float >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.MapInt64ToFloat)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      MapInt64ToFloat_VEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int64, float,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT,
      0 > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class MapInt64ToDouble_VEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapInt64ToDouble_VEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapInt64ToDouble_VEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
    0 > SuperType;
  MapInt64ToDouble_VEntry_DoNotUse();
  MapInt64ToDouble_VEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapInt64ToDouble_VEntry_DoNotUse& other);
  static const MapInt64ToDouble_VEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapInt64ToDouble_VEntry_DoNotUse*>(&_MapInt64ToDouble_VEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class MapInt64ToDouble :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.MapInt64ToDouble) */ {
 public:
  MapInt64ToDouble();
  virtual ~MapInt64ToDouble();

  MapInt64ToDouble(const MapInt64ToDouble& from);
  MapInt64ToDouble(MapInt64ToDouble&& from) noexcept
    : MapInt64ToDouble() {
    *this = ::std::move(from);
  }

  inline MapInt64ToDouble& operator=(const MapInt64ToDouble& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapInt64ToDouble& operator=(MapInt64ToDouble&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MapInt64ToDouble& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapInt64ToDouble* internal_default_instance() {
    return reinterpret_cast<const MapInt64ToDouble*>(
               &_MapInt64ToDouble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MapInt64ToDouble& a, MapInt64ToDouble& b) {
    a.Swap(&b);
  }
  inline void Swap(MapInt64ToDouble* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapInt64ToDouble* New() const final {
    return CreateMaybeMessage<MapInt64ToDouble>(nullptr);
  }

  MapInt64ToDouble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapInt64ToDouble>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MapInt64ToDouble& from);
  void MergeFrom(const MapInt64ToDouble& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapInt64ToDouble* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.MapInt64ToDouble";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // map<int64, double> v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, double >&
      _internal_v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, double >*
      _internal_mutable_v();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, double >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, double >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.MapInt64ToDouble)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      MapInt64ToDouble_VEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int64, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE,
      0 > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class VectorString :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.VectorString) */ {
 public:
  VectorString();
  virtual ~VectorString();

  VectorString(const VectorString& from);
  VectorString(VectorString&& from) noexcept
    : VectorString() {
    *this = ::std::move(from);
  }

  inline VectorString& operator=(const VectorString& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorString& operator=(VectorString&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VectorString& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorString* internal_default_instance() {
    return reinterpret_cast<const VectorString*>(
               &_VectorString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VectorString& a, VectorString& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorString* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorString* New() const final {
    return CreateMaybeMessage<VectorString>(nullptr);
  }

  VectorString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorString>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const VectorString& from);
  void MergeFrom(const VectorString& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VectorString* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.VectorString";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated string v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  const std::string& v(int index) const;
  std::string* mutable_v(int index);
  void set_v(int index, const std::string& value);
  void set_v(int index, std::string&& value);
  void set_v(int index, const char* value);
  void set_v(int index, const char* value, size_t size);
  std::string* add_v();
  void add_v(const std::string& value);
  void add_v(std::string&& value);
  void add_v(const char* value);
  void add_v(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& v() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_v();
  private:
  const std::string& _internal_v(int index) const;
  std::string* _internal_add_v();
  public:

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.VectorString)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class VectorFloat :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.VectorFloat) */ {
 public:
  VectorFloat();
  virtual ~VectorFloat();

  VectorFloat(const VectorFloat& from);
  VectorFloat(VectorFloat&& from) noexcept
    : VectorFloat() {
    *this = ::std::move(from);
  }

  inline VectorFloat& operator=(const VectorFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorFloat& operator=(VectorFloat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VectorFloat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorFloat* internal_default_instance() {
    return reinterpret_cast<const VectorFloat*>(
               &_VectorFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VectorFloat& a, VectorFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorFloat* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorFloat* New() const final {
    return CreateMaybeMessage<VectorFloat>(nullptr);
  }

  VectorFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorFloat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const VectorFloat& from);
  void MergeFrom(const VectorFloat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VectorFloat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.VectorFloat";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated float v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  float _internal_v(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_v() const;
  void _internal_add_v(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_v();
  public:
  float v(int index) const;
  void set_v(int index, float value);
  void add_v(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.VectorFloat)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class VectorInt64 :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.VectorInt64) */ {
 public:
  VectorInt64();
  virtual ~VectorInt64();

  VectorInt64(const VectorInt64& from);
  VectorInt64(VectorInt64&& from) noexcept
    : VectorInt64() {
    *this = ::std::move(from);
  }

  inline VectorInt64& operator=(const VectorInt64& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorInt64& operator=(VectorInt64&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VectorInt64& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorInt64* internal_default_instance() {
    return reinterpret_cast<const VectorInt64*>(
               &_VectorInt64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VectorInt64& a, VectorInt64& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorInt64* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorInt64* New() const final {
    return CreateMaybeMessage<VectorInt64>(nullptr);
  }

  VectorInt64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorInt64>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const VectorInt64& from);
  void MergeFrom(const VectorInt64& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VectorInt64* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.VectorInt64";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated int64 v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_v(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_v() const;
  void _internal_add_v(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_v();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 v(int index) const;
  void set_v(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_v(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.VectorInt64)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class VectorDouble :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.VectorDouble) */ {
 public:
  VectorDouble();
  virtual ~VectorDouble();

  VectorDouble(const VectorDouble& from);
  VectorDouble(VectorDouble&& from) noexcept
    : VectorDouble() {
    *this = ::std::move(from);
  }

  inline VectorDouble& operator=(const VectorDouble& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorDouble& operator=(VectorDouble&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VectorDouble& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorDouble* internal_default_instance() {
    return reinterpret_cast<const VectorDouble*>(
               &_VectorDouble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VectorDouble& a, VectorDouble& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorDouble* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorDouble* New() const final {
    return CreateMaybeMessage<VectorDouble>(nullptr);
  }

  VectorDouble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorDouble>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const VectorDouble& from);
  void MergeFrom(const VectorDouble& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VectorDouble* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.VectorDouble";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated double v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  private:
  double _internal_v(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_v() const;
  void _internal_add_v(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_v();
  public:
  double v(int index) const;
  void set_v(int index, double value);
  void add_v(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      v() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_v();

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.VectorDouble)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class VectorMapStringToFloat :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.VectorMapStringToFloat) */ {
 public:
  VectorMapStringToFloat();
  virtual ~VectorMapStringToFloat();

  VectorMapStringToFloat(const VectorMapStringToFloat& from);
  VectorMapStringToFloat(VectorMapStringToFloat&& from) noexcept
    : VectorMapStringToFloat() {
    *this = ::std::move(from);
  }

  inline VectorMapStringToFloat& operator=(const VectorMapStringToFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorMapStringToFloat& operator=(VectorMapStringToFloat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VectorMapStringToFloat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorMapStringToFloat* internal_default_instance() {
    return reinterpret_cast<const VectorMapStringToFloat*>(
               &_VectorMapStringToFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(VectorMapStringToFloat& a, VectorMapStringToFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorMapStringToFloat* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorMapStringToFloat* New() const final {
    return CreateMaybeMessage<VectorMapStringToFloat>(nullptr);
  }

  VectorMapStringToFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorMapStringToFloat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const VectorMapStringToFloat& from);
  void MergeFrom(const VectorMapStringToFloat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VectorMapStringToFloat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.VectorMapStringToFloat";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated .onnxruntime.proto.MapStringToFloat v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  ::onnxruntime::proto::MapStringToFloat* mutable_v(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onnxruntime::proto::MapStringToFloat >*
      mutable_v();
  private:
  const ::onnxruntime::proto::MapStringToFloat& _internal_v(int index) const;
  ::onnxruntime::proto::MapStringToFloat* _internal_add_v();
  public:
  const ::onnxruntime::proto::MapStringToFloat& v(int index) const;
  ::onnxruntime::proto::MapStringToFloat* add_v();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onnxruntime::proto::MapStringToFloat >&
      v() const;

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.VectorMapStringToFloat)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onnxruntime::proto::MapStringToFloat > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class VectorMapInt64ToFloat :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.VectorMapInt64ToFloat) */ {
 public:
  VectorMapInt64ToFloat();
  virtual ~VectorMapInt64ToFloat();

  VectorMapInt64ToFloat(const VectorMapInt64ToFloat& from);
  VectorMapInt64ToFloat(VectorMapInt64ToFloat&& from) noexcept
    : VectorMapInt64ToFloat() {
    *this = ::std::move(from);
  }

  inline VectorMapInt64ToFloat& operator=(const VectorMapInt64ToFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorMapInt64ToFloat& operator=(VectorMapInt64ToFloat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VectorMapInt64ToFloat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorMapInt64ToFloat* internal_default_instance() {
    return reinterpret_cast<const VectorMapInt64ToFloat*>(
               &_VectorMapInt64ToFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(VectorMapInt64ToFloat& a, VectorMapInt64ToFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorMapInt64ToFloat* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorMapInt64ToFloat* New() const final {
    return CreateMaybeMessage<VectorMapInt64ToFloat>(nullptr);
  }

  VectorMapInt64ToFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorMapInt64ToFloat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const VectorMapInt64ToFloat& from);
  void MergeFrom(const VectorMapInt64ToFloat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VectorMapInt64ToFloat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.VectorMapInt64ToFloat";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFieldNumber = 1,
  };
  // repeated .onnxruntime.proto.MapInt64ToFloat v = 1;
  int v_size() const;
  private:
  int _internal_v_size() const;
  public:
  void clear_v();
  ::onnxruntime::proto::MapInt64ToFloat* mutable_v(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onnxruntime::proto::MapInt64ToFloat >*
      mutable_v();
  private:
  const ::onnxruntime::proto::MapInt64ToFloat& _internal_v(int index) const;
  ::onnxruntime::proto::MapInt64ToFloat* _internal_add_v();
  public:
  const ::onnxruntime::proto::MapInt64ToFloat& v(int index) const;
  ::onnxruntime::proto::MapInt64ToFloat* add_v();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onnxruntime::proto::MapInt64ToFloat >&
      v() const;

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.VectorMapInt64ToFloat)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onnxruntime::proto::MapInt64ToFloat > v_;
  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class TraditionalMLData :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.TraditionalMLData) */ {
 public:
  TraditionalMLData();
  virtual ~TraditionalMLData();

  TraditionalMLData(const TraditionalMLData& from);
  TraditionalMLData(TraditionalMLData&& from) noexcept
    : TraditionalMLData() {
    *this = ::std::move(from);
  }

  inline TraditionalMLData& operator=(const TraditionalMLData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraditionalMLData& operator=(TraditionalMLData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TraditionalMLData& default_instance();

  enum ValuesCase {
    kMapStringToString = 1,
    kMapStringToInt64 = 2,
    kMapStringToFloat = 3,
    kMapStringToDouble = 4,
    kMapInt64ToString = 5,
    kMapInt64ToInt64 = 6,
    kMapInt64ToFloat = 7,
    kMapInt64ToDouble = 8,
    kVectorString = 9,
    kVectorFloat = 10,
    kVectorInt64 = 11,
    kVectorDouble = 12,
    kVectorMapStringToFloat = 13,
    kVectorMapInt64ToFloat = 14,
    kTensor = 16,
    VALUES_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TraditionalMLData* internal_default_instance() {
    return reinterpret_cast<const TraditionalMLData*>(
               &_TraditionalMLData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TraditionalMLData& a, TraditionalMLData& b) {
    a.Swap(&b);
  }
  inline void Swap(TraditionalMLData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TraditionalMLData* New() const final {
    return CreateMaybeMessage<TraditionalMLData>(nullptr);
  }

  TraditionalMLData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TraditionalMLData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TraditionalMLData& from);
  void MergeFrom(const TraditionalMLData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraditionalMLData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.TraditionalMLData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 15,
    kDebugInfoFieldNumber = 17,
    kMapStringToStringFieldNumber = 1,
    kMapStringToInt64FieldNumber = 2,
    kMapStringToFloatFieldNumber = 3,
    kMapStringToDoubleFieldNumber = 4,
    kMapInt64ToStringFieldNumber = 5,
    kMapInt64ToInt64FieldNumber = 6,
    kMapInt64ToFloatFieldNumber = 7,
    kMapInt64ToDoubleFieldNumber = 8,
    kVectorStringFieldNumber = 9,
    kVectorFloatFieldNumber = 10,
    kVectorInt64FieldNumber = 11,
    kVectorDoubleFieldNumber = 12,
    kVectorMapStringToFloatFieldNumber = 13,
    kVectorMapInt64ToFloatFieldNumber = 14,
    kTensorFieldNumber = 16,
  };
  // optional string name = 15;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string debug_info = 17;
  bool has_debug_info() const;
  private:
  bool _internal_has_debug_info() const;
  public:
  void clear_debug_info();
  const std::string& debug_info() const;
  void set_debug_info(const std::string& value);
  void set_debug_info(std::string&& value);
  void set_debug_info(const char* value);
  void set_debug_info(const char* value, size_t size);
  std::string* mutable_debug_info();
  std::string* release_debug_info();
  void set_allocated_debug_info(std::string* debug_info);
  private:
  const std::string& _internal_debug_info() const;
  void _internal_set_debug_info(const std::string& value);
  std::string* _internal_mutable_debug_info();
  public:

  // optional .onnxruntime.proto.MapStringToString map_string_to_string = 1;
  bool has_map_string_to_string() const;
  private:
  bool _internal_has_map_string_to_string() const;
  public:
  void clear_map_string_to_string();
  const ::onnxruntime::proto::MapStringToString& map_string_to_string() const;
  ::onnxruntime::proto::MapStringToString* release_map_string_to_string();
  ::onnxruntime::proto::MapStringToString* mutable_map_string_to_string();
  void set_allocated_map_string_to_string(::onnxruntime::proto::MapStringToString* map_string_to_string);
  private:
  const ::onnxruntime::proto::MapStringToString& _internal_map_string_to_string() const;
  ::onnxruntime::proto::MapStringToString* _internal_mutable_map_string_to_string();
  public:

  // optional .onnxruntime.proto.MapStringToInt64 map_string_to_int64 = 2;
  bool has_map_string_to_int64() const;
  private:
  bool _internal_has_map_string_to_int64() const;
  public:
  void clear_map_string_to_int64();
  const ::onnxruntime::proto::MapStringToInt64& map_string_to_int64() const;
  ::onnxruntime::proto::MapStringToInt64* release_map_string_to_int64();
  ::onnxruntime::proto::MapStringToInt64* mutable_map_string_to_int64();
  void set_allocated_map_string_to_int64(::onnxruntime::proto::MapStringToInt64* map_string_to_int64);
  private:
  const ::onnxruntime::proto::MapStringToInt64& _internal_map_string_to_int64() const;
  ::onnxruntime::proto::MapStringToInt64* _internal_mutable_map_string_to_int64();
  public:

  // optional .onnxruntime.proto.MapStringToFloat map_string_to_float = 3;
  bool has_map_string_to_float() const;
  private:
  bool _internal_has_map_string_to_float() const;
  public:
  void clear_map_string_to_float();
  const ::onnxruntime::proto::MapStringToFloat& map_string_to_float() const;
  ::onnxruntime::proto::MapStringToFloat* release_map_string_to_float();
  ::onnxruntime::proto::MapStringToFloat* mutable_map_string_to_float();
  void set_allocated_map_string_to_float(::onnxruntime::proto::MapStringToFloat* map_string_to_float);
  private:
  const ::onnxruntime::proto::MapStringToFloat& _internal_map_string_to_float() const;
  ::onnxruntime::proto::MapStringToFloat* _internal_mutable_map_string_to_float();
  public:

  // optional .onnxruntime.proto.MapStringToDouble map_string_to_double = 4;
  bool has_map_string_to_double() const;
  private:
  bool _internal_has_map_string_to_double() const;
  public:
  void clear_map_string_to_double();
  const ::onnxruntime::proto::MapStringToDouble& map_string_to_double() const;
  ::onnxruntime::proto::MapStringToDouble* release_map_string_to_double();
  ::onnxruntime::proto::MapStringToDouble* mutable_map_string_to_double();
  void set_allocated_map_string_to_double(::onnxruntime::proto::MapStringToDouble* map_string_to_double);
  private:
  const ::onnxruntime::proto::MapStringToDouble& _internal_map_string_to_double() const;
  ::onnxruntime::proto::MapStringToDouble* _internal_mutable_map_string_to_double();
  public:

  // optional .onnxruntime.proto.MapInt64ToString map_int64_to_string = 5;
  bool has_map_int64_to_string() const;
  private:
  bool _internal_has_map_int64_to_string() const;
  public:
  void clear_map_int64_to_string();
  const ::onnxruntime::proto::MapInt64ToString& map_int64_to_string() const;
  ::onnxruntime::proto::MapInt64ToString* release_map_int64_to_string();
  ::onnxruntime::proto::MapInt64ToString* mutable_map_int64_to_string();
  void set_allocated_map_int64_to_string(::onnxruntime::proto::MapInt64ToString* map_int64_to_string);
  private:
  const ::onnxruntime::proto::MapInt64ToString& _internal_map_int64_to_string() const;
  ::onnxruntime::proto::MapInt64ToString* _internal_mutable_map_int64_to_string();
  public:

  // optional .onnxruntime.proto.MapInt64ToInt64 map_int64_to_int64 = 6;
  bool has_map_int64_to_int64() const;
  private:
  bool _internal_has_map_int64_to_int64() const;
  public:
  void clear_map_int64_to_int64();
  const ::onnxruntime::proto::MapInt64ToInt64& map_int64_to_int64() const;
  ::onnxruntime::proto::MapInt64ToInt64* release_map_int64_to_int64();
  ::onnxruntime::proto::MapInt64ToInt64* mutable_map_int64_to_int64();
  void set_allocated_map_int64_to_int64(::onnxruntime::proto::MapInt64ToInt64* map_int64_to_int64);
  private:
  const ::onnxruntime::proto::MapInt64ToInt64& _internal_map_int64_to_int64() const;
  ::onnxruntime::proto::MapInt64ToInt64* _internal_mutable_map_int64_to_int64();
  public:

  // optional .onnxruntime.proto.MapInt64ToFloat map_int64_to_float = 7;
  bool has_map_int64_to_float() const;
  private:
  bool _internal_has_map_int64_to_float() const;
  public:
  void clear_map_int64_to_float();
  const ::onnxruntime::proto::MapInt64ToFloat& map_int64_to_float() const;
  ::onnxruntime::proto::MapInt64ToFloat* release_map_int64_to_float();
  ::onnxruntime::proto::MapInt64ToFloat* mutable_map_int64_to_float();
  void set_allocated_map_int64_to_float(::onnxruntime::proto::MapInt64ToFloat* map_int64_to_float);
  private:
  const ::onnxruntime::proto::MapInt64ToFloat& _internal_map_int64_to_float() const;
  ::onnxruntime::proto::MapInt64ToFloat* _internal_mutable_map_int64_to_float();
  public:

  // optional .onnxruntime.proto.MapInt64ToDouble map_int64_to_double = 8;
  bool has_map_int64_to_double() const;
  private:
  bool _internal_has_map_int64_to_double() const;
  public:
  void clear_map_int64_to_double();
  const ::onnxruntime::proto::MapInt64ToDouble& map_int64_to_double() const;
  ::onnxruntime::proto::MapInt64ToDouble* release_map_int64_to_double();
  ::onnxruntime::proto::MapInt64ToDouble* mutable_map_int64_to_double();
  void set_allocated_map_int64_to_double(::onnxruntime::proto::MapInt64ToDouble* map_int64_to_double);
  private:
  const ::onnxruntime::proto::MapInt64ToDouble& _internal_map_int64_to_double() const;
  ::onnxruntime::proto::MapInt64ToDouble* _internal_mutable_map_int64_to_double();
  public:

  // optional .onnxruntime.proto.VectorString vector_string = 9;
  bool has_vector_string() const;
  private:
  bool _internal_has_vector_string() const;
  public:
  void clear_vector_string();
  const ::onnxruntime::proto::VectorString& vector_string() const;
  ::onnxruntime::proto::VectorString* release_vector_string();
  ::onnxruntime::proto::VectorString* mutable_vector_string();
  void set_allocated_vector_string(::onnxruntime::proto::VectorString* vector_string);
  private:
  const ::onnxruntime::proto::VectorString& _internal_vector_string() const;
  ::onnxruntime::proto::VectorString* _internal_mutable_vector_string();
  public:

  // optional .onnxruntime.proto.VectorFloat vector_float = 10;
  bool has_vector_float() const;
  private:
  bool _internal_has_vector_float() const;
  public:
  void clear_vector_float();
  const ::onnxruntime::proto::VectorFloat& vector_float() const;
  ::onnxruntime::proto::VectorFloat* release_vector_float();
  ::onnxruntime::proto::VectorFloat* mutable_vector_float();
  void set_allocated_vector_float(::onnxruntime::proto::VectorFloat* vector_float);
  private:
  const ::onnxruntime::proto::VectorFloat& _internal_vector_float() const;
  ::onnxruntime::proto::VectorFloat* _internal_mutable_vector_float();
  public:

  // optional .onnxruntime.proto.VectorInt64 vector_int64 = 11;
  bool has_vector_int64() const;
  private:
  bool _internal_has_vector_int64() const;
  public:
  void clear_vector_int64();
  const ::onnxruntime::proto::VectorInt64& vector_int64() const;
  ::onnxruntime::proto::VectorInt64* release_vector_int64();
  ::onnxruntime::proto::VectorInt64* mutable_vector_int64();
  void set_allocated_vector_int64(::onnxruntime::proto::VectorInt64* vector_int64);
  private:
  const ::onnxruntime::proto::VectorInt64& _internal_vector_int64() const;
  ::onnxruntime::proto::VectorInt64* _internal_mutable_vector_int64();
  public:

  // optional .onnxruntime.proto.VectorDouble vector_double = 12;
  bool has_vector_double() const;
  private:
  bool _internal_has_vector_double() const;
  public:
  void clear_vector_double();
  const ::onnxruntime::proto::VectorDouble& vector_double() const;
  ::onnxruntime::proto::VectorDouble* release_vector_double();
  ::onnxruntime::proto::VectorDouble* mutable_vector_double();
  void set_allocated_vector_double(::onnxruntime::proto::VectorDouble* vector_double);
  private:
  const ::onnxruntime::proto::VectorDouble& _internal_vector_double() const;
  ::onnxruntime::proto::VectorDouble* _internal_mutable_vector_double();
  public:

  // optional .onnxruntime.proto.VectorMapStringToFloat vector_map_string_to_float = 13;
  bool has_vector_map_string_to_float() const;
  private:
  bool _internal_has_vector_map_string_to_float() const;
  public:
  void clear_vector_map_string_to_float();
  const ::onnxruntime::proto::VectorMapStringToFloat& vector_map_string_to_float() const;
  ::onnxruntime::proto::VectorMapStringToFloat* release_vector_map_string_to_float();
  ::onnxruntime::proto::VectorMapStringToFloat* mutable_vector_map_string_to_float();
  void set_allocated_vector_map_string_to_float(::onnxruntime::proto::VectorMapStringToFloat* vector_map_string_to_float);
  private:
  const ::onnxruntime::proto::VectorMapStringToFloat& _internal_vector_map_string_to_float() const;
  ::onnxruntime::proto::VectorMapStringToFloat* _internal_mutable_vector_map_string_to_float();
  public:

  // optional .onnxruntime.proto.VectorMapInt64ToFloat vector_map_int64_to_float = 14;
  bool has_vector_map_int64_to_float() const;
  private:
  bool _internal_has_vector_map_int64_to_float() const;
  public:
  void clear_vector_map_int64_to_float();
  const ::onnxruntime::proto::VectorMapInt64ToFloat& vector_map_int64_to_float() const;
  ::onnxruntime::proto::VectorMapInt64ToFloat* release_vector_map_int64_to_float();
  ::onnxruntime::proto::VectorMapInt64ToFloat* mutable_vector_map_int64_to_float();
  void set_allocated_vector_map_int64_to_float(::onnxruntime::proto::VectorMapInt64ToFloat* vector_map_int64_to_float);
  private:
  const ::onnxruntime::proto::VectorMapInt64ToFloat& _internal_vector_map_int64_to_float() const;
  ::onnxruntime::proto::VectorMapInt64ToFloat* _internal_mutable_vector_map_int64_to_float();
  public:

  // optional .onnx.TensorProto tensor = 16;
  bool has_tensor() const;
  private:
  bool _internal_has_tensor() const;
  public:
  void clear_tensor();
  const ::onnx::TensorProto& tensor() const;
  ::onnx::TensorProto* release_tensor();
  ::onnx::TensorProto* mutable_tensor();
  void set_allocated_tensor(::onnx::TensorProto* tensor);
  private:
  const ::onnx::TensorProto& _internal_tensor() const;
  ::onnx::TensorProto* _internal_mutable_tensor();
  public:

  void clear_values();
  ValuesCase values_case() const;
  // @@protoc_insertion_point(class_scope:onnxruntime.proto.TraditionalMLData)
 private:
  class _Internal;
  void set_has_map_string_to_string();
  void set_has_map_string_to_int64();
  void set_has_map_string_to_float();
  void set_has_map_string_to_double();
  void set_has_map_int64_to_string();
  void set_has_map_int64_to_int64();
  void set_has_map_int64_to_float();
  void set_has_map_int64_to_double();
  void set_has_vector_string();
  void set_has_vector_float();
  void set_has_vector_int64();
  void set_has_vector_double();
  void set_has_vector_map_string_to_float();
  void set_has_vector_map_int64_to_float();
  void set_has_tensor();

  inline bool has_values() const;
  inline void clear_has_values();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_info_;
  union ValuesUnion {
    ValuesUnion() {}
    ::onnxruntime::proto::MapStringToString* map_string_to_string_;
    ::onnxruntime::proto::MapStringToInt64* map_string_to_int64_;
    ::onnxruntime::proto::MapStringToFloat* map_string_to_float_;
    ::onnxruntime::proto::MapStringToDouble* map_string_to_double_;
    ::onnxruntime::proto::MapInt64ToString* map_int64_to_string_;
    ::onnxruntime::proto::MapInt64ToInt64* map_int64_to_int64_;
    ::onnxruntime::proto::MapInt64ToFloat* map_int64_to_float_;
    ::onnxruntime::proto::MapInt64ToDouble* map_int64_to_double_;
    ::onnxruntime::proto::VectorString* vector_string_;
    ::onnxruntime::proto::VectorFloat* vector_float_;
    ::onnxruntime::proto::VectorInt64* vector_int64_;
    ::onnxruntime::proto::VectorDouble* vector_double_;
    ::onnxruntime::proto::VectorMapStringToFloat* vector_map_string_to_float_;
    ::onnxruntime::proto::VectorMapInt64ToFloat* vector_map_int64_to_float_;
    ::onnx::TensorProto* tensor_;
  } values_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_tml_2eproto;
};
// -------------------------------------------------------------------

class TestCaseConfig :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:onnxruntime.proto.TestCaseConfig) */ {
 public:
  TestCaseConfig();
  virtual ~TestCaseConfig();

  TestCaseConfig(const TestCaseConfig& from);
  TestCaseConfig(TestCaseConfig&& from) noexcept
    : TestCaseConfig() {
    *this = ::std::move(from);
  }

  inline TestCaseConfig& operator=(const TestCaseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestCaseConfig& operator=(TestCaseConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TestCaseConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestCaseConfig* internal_default_instance() {
    return reinterpret_cast<const TestCaseConfig*>(
               &_TestCaseConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TestCaseConfig& a, TestCaseConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TestCaseConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestCaseConfig* New() const final {
    return CreateMaybeMessage<TestCaseConfig>(nullptr);
  }

  TestCaseConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestCaseConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TestCaseConfig& from);
  void MergeFrom(const TestCaseConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestCaseConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onnxruntime.proto.TestCaseConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerSampleToleranceFieldNumber = 1,
    kRelativePerSampleToleranceFieldNumber = 2,
    kPostProcessingFieldNumber = 3,
  };
  // optional double per_sample_tolerance = 1;
  bool has_per_sample_tolerance() const;
  private:
  bool _internal_has_per_sample_tolerance() const;
  public:
  void clear_per_sample_tolerance();
  double per_sample_tolerance() const;
  void set_per_sample_tolerance(double value);
  private:
  double _internal_per_sample_tolerance() const;
  void _internal_set_per_sample_tolerance(double value);
  public:

  // optional double relative_per_sample_tolerance = 2;
  bool has_relative_per_sample_tolerance() const;
  private:
  bool _internal_has_relative_per_sample_tolerance() const;
  public:
  void clear_relative_per_sample_tolerance();
  double relative_per_sample_tolerance() const;
  void set_relative_per_sample_tolerance(double value);
  private:
  double _internal_relative_per_sample_tolerance() const;
  void _internal_set_relative_per_sample_tolerance(double value);
  public:

  // optional bool post_processing = 3;
  bool has_post_processing() const;
  private:
  bool _internal_has_post_processing() const;
  public:
  void clear_post_processing();
  bool post_processing() const;
  void set_post_processing(bool value);
  private:
  bool _internal_post_processing() const;
  void _internal_set_post_processing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:onnxruntime.proto.TestCaseConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double per_sample_tolerance_;
  double relative_per_sample_tolerance_;
  bool post_processing_;
  friend struct ::TableStruct_tml_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MapStringToString

// map<string, string> v = 1;
inline int MapStringToString::_internal_v_size() const {
  return v_.size();
}
inline int MapStringToString::v_size() const {
  return _internal_v_size();
}
inline void MapStringToString::clear_v() {
  v_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MapStringToString::_internal_v() const {
  return v_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MapStringToString::v() const {
  // @@protoc_insertion_point(field_map:onnxruntime.proto.MapStringToString.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MapStringToString::_internal_mutable_v() {
  return v_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MapStringToString::mutable_v() {
  // @@protoc_insertion_point(field_mutable_map:onnxruntime.proto.MapStringToString.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapStringToInt64

// map<string, int64> v = 1;
inline int MapStringToInt64::_internal_v_size() const {
  return v_.size();
}
inline int MapStringToInt64::v_size() const {
  return _internal_v_size();
}
inline void MapStringToInt64::clear_v() {
  v_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
MapStringToInt64::_internal_v() const {
  return v_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
MapStringToInt64::v() const {
  // @@protoc_insertion_point(field_map:onnxruntime.proto.MapStringToInt64.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
MapStringToInt64::_internal_mutable_v() {
  return v_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
MapStringToInt64::mutable_v() {
  // @@protoc_insertion_point(field_mutable_map:onnxruntime.proto.MapStringToInt64.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapStringToDouble

// map<string, double> v = 1;
inline int MapStringToDouble::_internal_v_size() const {
  return v_.size();
}
inline int MapStringToDouble::v_size() const {
  return _internal_v_size();
}
inline void MapStringToDouble::clear_v() {
  v_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
MapStringToDouble::_internal_v() const {
  return v_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
MapStringToDouble::v() const {
  // @@protoc_insertion_point(field_map:onnxruntime.proto.MapStringToDouble.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
MapStringToDouble::_internal_mutable_v() {
  return v_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
MapStringToDouble::mutable_v() {
  // @@protoc_insertion_point(field_mutable_map:onnxruntime.proto.MapStringToDouble.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapStringToFloat

// map<string, float> v = 1;
inline int MapStringToFloat::_internal_v_size() const {
  return v_.size();
}
inline int MapStringToFloat::v_size() const {
  return _internal_v_size();
}
inline void MapStringToFloat::clear_v() {
  v_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
MapStringToFloat::_internal_v() const {
  return v_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
MapStringToFloat::v() const {
  // @@protoc_insertion_point(field_map:onnxruntime.proto.MapStringToFloat.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
MapStringToFloat::_internal_mutable_v() {
  return v_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
MapStringToFloat::mutable_v() {
  // @@protoc_insertion_point(field_mutable_map:onnxruntime.proto.MapStringToFloat.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapInt64ToString

// map<int64, string> v = 1;
inline int MapInt64ToString::_internal_v_size() const {
  return v_.size();
}
inline int MapInt64ToString::v_size() const {
  return _internal_v_size();
}
inline void MapInt64ToString::clear_v() {
  v_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, std::string >&
MapInt64ToString::_internal_v() const {
  return v_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, std::string >&
MapInt64ToString::v() const {
  // @@protoc_insertion_point(field_map:onnxruntime.proto.MapInt64ToString.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, std::string >*
MapInt64ToString::_internal_mutable_v() {
  return v_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, std::string >*
MapInt64ToString::mutable_v() {
  // @@protoc_insertion_point(field_mutable_map:onnxruntime.proto.MapInt64ToString.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapInt64ToInt64

// map<int64, int64> v = 1;
inline int MapInt64ToInt64::_internal_v_size() const {
  return v_.size();
}
inline int MapInt64ToInt64::v_size() const {
  return _internal_v_size();
}
inline void MapInt64ToInt64::clear_v() {
  v_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64 >&
MapInt64ToInt64::_internal_v() const {
  return v_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64 >&
MapInt64ToInt64::v() const {
  // @@protoc_insertion_point(field_map:onnxruntime.proto.MapInt64ToInt64.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64 >*
MapInt64ToInt64::_internal_mutable_v() {
  return v_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::int64 >*
MapInt64ToInt64::mutable_v() {
  // @@protoc_insertion_point(field_mutable_map:onnxruntime.proto.MapInt64ToInt64.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapInt64ToFloat

// map<int64, float> v = 1;
inline int MapInt64ToFloat::_internal_v_size() const {
  return v_.size();
}
inline int MapInt64ToFloat::v_size() const {
  return _internal_v_size();
}
inline void MapInt64ToFloat::clear_v() {
  v_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, float >&
MapInt64ToFloat::_internal_v() const {
  return v_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, float >&
MapInt64ToFloat::v() const {
  // @@protoc_insertion_point(field_map:onnxruntime.proto.MapInt64ToFloat.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, float >*
MapInt64ToFloat::_internal_mutable_v() {
  return v_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, float >*
MapInt64ToFloat::mutable_v() {
  // @@protoc_insertion_point(field_mutable_map:onnxruntime.proto.MapInt64ToFloat.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapInt64ToDouble

// map<int64, double> v = 1;
inline int MapInt64ToDouble::_internal_v_size() const {
  return v_.size();
}
inline int MapInt64ToDouble::v_size() const {
  return _internal_v_size();
}
inline void MapInt64ToDouble::clear_v() {
  v_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, double >&
MapInt64ToDouble::_internal_v() const {
  return v_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, double >&
MapInt64ToDouble::v() const {
  // @@protoc_insertion_point(field_map:onnxruntime.proto.MapInt64ToDouble.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, double >*
MapInt64ToDouble::_internal_mutable_v() {
  return v_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, double >*
MapInt64ToDouble::mutable_v() {
  // @@protoc_insertion_point(field_mutable_map:onnxruntime.proto.MapInt64ToDouble.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// VectorString

// repeated string v = 1;
inline int VectorString::_internal_v_size() const {
  return v_.size();
}
inline int VectorString::v_size() const {
  return _internal_v_size();
}
inline void VectorString::clear_v() {
  v_.Clear();
}
inline std::string* VectorString::add_v() {
  // @@protoc_insertion_point(field_add_mutable:onnxruntime.proto.VectorString.v)
  return _internal_add_v();
}
inline const std::string& VectorString::_internal_v(int index) const {
  return v_.Get(index);
}
inline const std::string& VectorString::v(int index) const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.VectorString.v)
  return _internal_v(index);
}
inline std::string* VectorString::mutable_v(int index) {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.VectorString.v)
  return v_.Mutable(index);
}
inline void VectorString::set_v(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:onnxruntime.proto.VectorString.v)
  v_.Mutable(index)->assign(value);
}
inline void VectorString::set_v(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:onnxruntime.proto.VectorString.v)
  v_.Mutable(index)->assign(std::move(value));
}
inline void VectorString::set_v(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  v_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:onnxruntime.proto.VectorString.v)
}
inline void VectorString::set_v(int index, const char* value, size_t size) {
  v_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:onnxruntime.proto.VectorString.v)
}
inline std::string* VectorString::_internal_add_v() {
  return v_.Add();
}
inline void VectorString::add_v(const std::string& value) {
  v_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:onnxruntime.proto.VectorString.v)
}
inline void VectorString::add_v(std::string&& value) {
  v_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:onnxruntime.proto.VectorString.v)
}
inline void VectorString::add_v(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  v_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:onnxruntime.proto.VectorString.v)
}
inline void VectorString::add_v(const char* value, size_t size) {
  v_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:onnxruntime.proto.VectorString.v)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VectorString::v() const {
  // @@protoc_insertion_point(field_list:onnxruntime.proto.VectorString.v)
  return v_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VectorString::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:onnxruntime.proto.VectorString.v)
  return &v_;
}

// -------------------------------------------------------------------

// VectorFloat

// repeated float v = 1;
inline int VectorFloat::_internal_v_size() const {
  return v_.size();
}
inline int VectorFloat::v_size() const {
  return _internal_v_size();
}
inline void VectorFloat::clear_v() {
  v_.Clear();
}
inline float VectorFloat::_internal_v(int index) const {
  return v_.Get(index);
}
inline float VectorFloat::v(int index) const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.VectorFloat.v)
  return _internal_v(index);
}
inline void VectorFloat::set_v(int index, float value) {
  v_.Set(index, value);
  // @@protoc_insertion_point(field_set:onnxruntime.proto.VectorFloat.v)
}
inline void VectorFloat::_internal_add_v(float value) {
  v_.Add(value);
}
inline void VectorFloat::add_v(float value) {
  _internal_add_v(value);
  // @@protoc_insertion_point(field_add:onnxruntime.proto.VectorFloat.v)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VectorFloat::_internal_v() const {
  return v_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VectorFloat::v() const {
  // @@protoc_insertion_point(field_list:onnxruntime.proto.VectorFloat.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VectorFloat::_internal_mutable_v() {
  return &v_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VectorFloat::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:onnxruntime.proto.VectorFloat.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// VectorInt64

// repeated int64 v = 1;
inline int VectorInt64::_internal_v_size() const {
  return v_.size();
}
inline int VectorInt64::v_size() const {
  return _internal_v_size();
}
inline void VectorInt64::clear_v() {
  v_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VectorInt64::_internal_v(int index) const {
  return v_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VectorInt64::v(int index) const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.VectorInt64.v)
  return _internal_v(index);
}
inline void VectorInt64::set_v(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  v_.Set(index, value);
  // @@protoc_insertion_point(field_set:onnxruntime.proto.VectorInt64.v)
}
inline void VectorInt64::_internal_add_v(::PROTOBUF_NAMESPACE_ID::int64 value) {
  v_.Add(value);
}
inline void VectorInt64::add_v(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_v(value);
  // @@protoc_insertion_point(field_add:onnxruntime.proto.VectorInt64.v)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
VectorInt64::_internal_v() const {
  return v_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
VectorInt64::v() const {
  // @@protoc_insertion_point(field_list:onnxruntime.proto.VectorInt64.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
VectorInt64::_internal_mutable_v() {
  return &v_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
VectorInt64::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:onnxruntime.proto.VectorInt64.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// VectorDouble

// repeated double v = 1;
inline int VectorDouble::_internal_v_size() const {
  return v_.size();
}
inline int VectorDouble::v_size() const {
  return _internal_v_size();
}
inline void VectorDouble::clear_v() {
  v_.Clear();
}
inline double VectorDouble::_internal_v(int index) const {
  return v_.Get(index);
}
inline double VectorDouble::v(int index) const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.VectorDouble.v)
  return _internal_v(index);
}
inline void VectorDouble::set_v(int index, double value) {
  v_.Set(index, value);
  // @@protoc_insertion_point(field_set:onnxruntime.proto.VectorDouble.v)
}
inline void VectorDouble::_internal_add_v(double value) {
  v_.Add(value);
}
inline void VectorDouble::add_v(double value) {
  _internal_add_v(value);
  // @@protoc_insertion_point(field_add:onnxruntime.proto.VectorDouble.v)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
VectorDouble::_internal_v() const {
  return v_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
VectorDouble::v() const {
  // @@protoc_insertion_point(field_list:onnxruntime.proto.VectorDouble.v)
  return _internal_v();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
VectorDouble::_internal_mutable_v() {
  return &v_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
VectorDouble::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:onnxruntime.proto.VectorDouble.v)
  return _internal_mutable_v();
}

// -------------------------------------------------------------------

// VectorMapStringToFloat

// repeated .onnxruntime.proto.MapStringToFloat v = 1;
inline int VectorMapStringToFloat::_internal_v_size() const {
  return v_.size();
}
inline int VectorMapStringToFloat::v_size() const {
  return _internal_v_size();
}
inline void VectorMapStringToFloat::clear_v() {
  v_.Clear();
}
inline ::onnxruntime::proto::MapStringToFloat* VectorMapStringToFloat::mutable_v(int index) {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.VectorMapStringToFloat.v)
  return v_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onnxruntime::proto::MapStringToFloat >*
VectorMapStringToFloat::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:onnxruntime.proto.VectorMapStringToFloat.v)
  return &v_;
}
inline const ::onnxruntime::proto::MapStringToFloat& VectorMapStringToFloat::_internal_v(int index) const {
  return v_.Get(index);
}
inline const ::onnxruntime::proto::MapStringToFloat& VectorMapStringToFloat::v(int index) const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.VectorMapStringToFloat.v)
  return _internal_v(index);
}
inline ::onnxruntime::proto::MapStringToFloat* VectorMapStringToFloat::_internal_add_v() {
  return v_.Add();
}
inline ::onnxruntime::proto::MapStringToFloat* VectorMapStringToFloat::add_v() {
  // @@protoc_insertion_point(field_add:onnxruntime.proto.VectorMapStringToFloat.v)
  return _internal_add_v();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onnxruntime::proto::MapStringToFloat >&
VectorMapStringToFloat::v() const {
  // @@protoc_insertion_point(field_list:onnxruntime.proto.VectorMapStringToFloat.v)
  return v_;
}

// -------------------------------------------------------------------

// VectorMapInt64ToFloat

// repeated .onnxruntime.proto.MapInt64ToFloat v = 1;
inline int VectorMapInt64ToFloat::_internal_v_size() const {
  return v_.size();
}
inline int VectorMapInt64ToFloat::v_size() const {
  return _internal_v_size();
}
inline void VectorMapInt64ToFloat::clear_v() {
  v_.Clear();
}
inline ::onnxruntime::proto::MapInt64ToFloat* VectorMapInt64ToFloat::mutable_v(int index) {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.VectorMapInt64ToFloat.v)
  return v_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onnxruntime::proto::MapInt64ToFloat >*
VectorMapInt64ToFloat::mutable_v() {
  // @@protoc_insertion_point(field_mutable_list:onnxruntime.proto.VectorMapInt64ToFloat.v)
  return &v_;
}
inline const ::onnxruntime::proto::MapInt64ToFloat& VectorMapInt64ToFloat::_internal_v(int index) const {
  return v_.Get(index);
}
inline const ::onnxruntime::proto::MapInt64ToFloat& VectorMapInt64ToFloat::v(int index) const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.VectorMapInt64ToFloat.v)
  return _internal_v(index);
}
inline ::onnxruntime::proto::MapInt64ToFloat* VectorMapInt64ToFloat::_internal_add_v() {
  return v_.Add();
}
inline ::onnxruntime::proto::MapInt64ToFloat* VectorMapInt64ToFloat::add_v() {
  // @@protoc_insertion_point(field_add:onnxruntime.proto.VectorMapInt64ToFloat.v)
  return _internal_add_v();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onnxruntime::proto::MapInt64ToFloat >&
VectorMapInt64ToFloat::v() const {
  // @@protoc_insertion_point(field_list:onnxruntime.proto.VectorMapInt64ToFloat.v)
  return v_;
}

// -------------------------------------------------------------------

// TraditionalMLData

// optional .onnxruntime.proto.MapStringToString map_string_to_string = 1;
inline bool TraditionalMLData::_internal_has_map_string_to_string() const {
  return values_case() == kMapStringToString;
}
inline bool TraditionalMLData::has_map_string_to_string() const {
  return _internal_has_map_string_to_string();
}
inline void TraditionalMLData::set_has_map_string_to_string() {
  _oneof_case_[0] = kMapStringToString;
}
inline void TraditionalMLData::clear_map_string_to_string() {
  if (_internal_has_map_string_to_string()) {
    delete values_.map_string_to_string_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::MapStringToString* TraditionalMLData::release_map_string_to_string() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.map_string_to_string)
  if (_internal_has_map_string_to_string()) {
    clear_has_values();
      ::onnxruntime::proto::MapStringToString* temp = values_.map_string_to_string_;
    values_.map_string_to_string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::MapStringToString& TraditionalMLData::_internal_map_string_to_string() const {
  return _internal_has_map_string_to_string()
      ? *values_.map_string_to_string_
      : *reinterpret_cast< ::onnxruntime::proto::MapStringToString*>(&::onnxruntime::proto::_MapStringToString_default_instance_);
}
inline const ::onnxruntime::proto::MapStringToString& TraditionalMLData::map_string_to_string() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.map_string_to_string)
  return _internal_map_string_to_string();
}
inline ::onnxruntime::proto::MapStringToString* TraditionalMLData::_internal_mutable_map_string_to_string() {
  if (!_internal_has_map_string_to_string()) {
    clear_values();
    set_has_map_string_to_string();
    values_.map_string_to_string_ = CreateMaybeMessage< ::onnxruntime::proto::MapStringToString >(
        GetArenaNoVirtual());
  }
  return values_.map_string_to_string_;
}
inline ::onnxruntime::proto::MapStringToString* TraditionalMLData::mutable_map_string_to_string() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.map_string_to_string)
  return _internal_mutable_map_string_to_string();
}

// optional .onnxruntime.proto.MapStringToInt64 map_string_to_int64 = 2;
inline bool TraditionalMLData::_internal_has_map_string_to_int64() const {
  return values_case() == kMapStringToInt64;
}
inline bool TraditionalMLData::has_map_string_to_int64() const {
  return _internal_has_map_string_to_int64();
}
inline void TraditionalMLData::set_has_map_string_to_int64() {
  _oneof_case_[0] = kMapStringToInt64;
}
inline void TraditionalMLData::clear_map_string_to_int64() {
  if (_internal_has_map_string_to_int64()) {
    delete values_.map_string_to_int64_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::MapStringToInt64* TraditionalMLData::release_map_string_to_int64() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.map_string_to_int64)
  if (_internal_has_map_string_to_int64()) {
    clear_has_values();
      ::onnxruntime::proto::MapStringToInt64* temp = values_.map_string_to_int64_;
    values_.map_string_to_int64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::MapStringToInt64& TraditionalMLData::_internal_map_string_to_int64() const {
  return _internal_has_map_string_to_int64()
      ? *values_.map_string_to_int64_
      : *reinterpret_cast< ::onnxruntime::proto::MapStringToInt64*>(&::onnxruntime::proto::_MapStringToInt64_default_instance_);
}
inline const ::onnxruntime::proto::MapStringToInt64& TraditionalMLData::map_string_to_int64() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.map_string_to_int64)
  return _internal_map_string_to_int64();
}
inline ::onnxruntime::proto::MapStringToInt64* TraditionalMLData::_internal_mutable_map_string_to_int64() {
  if (!_internal_has_map_string_to_int64()) {
    clear_values();
    set_has_map_string_to_int64();
    values_.map_string_to_int64_ = CreateMaybeMessage< ::onnxruntime::proto::MapStringToInt64 >(
        GetArenaNoVirtual());
  }
  return values_.map_string_to_int64_;
}
inline ::onnxruntime::proto::MapStringToInt64* TraditionalMLData::mutable_map_string_to_int64() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.map_string_to_int64)
  return _internal_mutable_map_string_to_int64();
}

// optional .onnxruntime.proto.MapStringToFloat map_string_to_float = 3;
inline bool TraditionalMLData::_internal_has_map_string_to_float() const {
  return values_case() == kMapStringToFloat;
}
inline bool TraditionalMLData::has_map_string_to_float() const {
  return _internal_has_map_string_to_float();
}
inline void TraditionalMLData::set_has_map_string_to_float() {
  _oneof_case_[0] = kMapStringToFloat;
}
inline void TraditionalMLData::clear_map_string_to_float() {
  if (_internal_has_map_string_to_float()) {
    delete values_.map_string_to_float_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::MapStringToFloat* TraditionalMLData::release_map_string_to_float() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.map_string_to_float)
  if (_internal_has_map_string_to_float()) {
    clear_has_values();
      ::onnxruntime::proto::MapStringToFloat* temp = values_.map_string_to_float_;
    values_.map_string_to_float_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::MapStringToFloat& TraditionalMLData::_internal_map_string_to_float() const {
  return _internal_has_map_string_to_float()
      ? *values_.map_string_to_float_
      : *reinterpret_cast< ::onnxruntime::proto::MapStringToFloat*>(&::onnxruntime::proto::_MapStringToFloat_default_instance_);
}
inline const ::onnxruntime::proto::MapStringToFloat& TraditionalMLData::map_string_to_float() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.map_string_to_float)
  return _internal_map_string_to_float();
}
inline ::onnxruntime::proto::MapStringToFloat* TraditionalMLData::_internal_mutable_map_string_to_float() {
  if (!_internal_has_map_string_to_float()) {
    clear_values();
    set_has_map_string_to_float();
    values_.map_string_to_float_ = CreateMaybeMessage< ::onnxruntime::proto::MapStringToFloat >(
        GetArenaNoVirtual());
  }
  return values_.map_string_to_float_;
}
inline ::onnxruntime::proto::MapStringToFloat* TraditionalMLData::mutable_map_string_to_float() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.map_string_to_float)
  return _internal_mutable_map_string_to_float();
}

// optional .onnxruntime.proto.MapStringToDouble map_string_to_double = 4;
inline bool TraditionalMLData::_internal_has_map_string_to_double() const {
  return values_case() == kMapStringToDouble;
}
inline bool TraditionalMLData::has_map_string_to_double() const {
  return _internal_has_map_string_to_double();
}
inline void TraditionalMLData::set_has_map_string_to_double() {
  _oneof_case_[0] = kMapStringToDouble;
}
inline void TraditionalMLData::clear_map_string_to_double() {
  if (_internal_has_map_string_to_double()) {
    delete values_.map_string_to_double_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::MapStringToDouble* TraditionalMLData::release_map_string_to_double() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.map_string_to_double)
  if (_internal_has_map_string_to_double()) {
    clear_has_values();
      ::onnxruntime::proto::MapStringToDouble* temp = values_.map_string_to_double_;
    values_.map_string_to_double_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::MapStringToDouble& TraditionalMLData::_internal_map_string_to_double() const {
  return _internal_has_map_string_to_double()
      ? *values_.map_string_to_double_
      : *reinterpret_cast< ::onnxruntime::proto::MapStringToDouble*>(&::onnxruntime::proto::_MapStringToDouble_default_instance_);
}
inline const ::onnxruntime::proto::MapStringToDouble& TraditionalMLData::map_string_to_double() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.map_string_to_double)
  return _internal_map_string_to_double();
}
inline ::onnxruntime::proto::MapStringToDouble* TraditionalMLData::_internal_mutable_map_string_to_double() {
  if (!_internal_has_map_string_to_double()) {
    clear_values();
    set_has_map_string_to_double();
    values_.map_string_to_double_ = CreateMaybeMessage< ::onnxruntime::proto::MapStringToDouble >(
        GetArenaNoVirtual());
  }
  return values_.map_string_to_double_;
}
inline ::onnxruntime::proto::MapStringToDouble* TraditionalMLData::mutable_map_string_to_double() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.map_string_to_double)
  return _internal_mutable_map_string_to_double();
}

// optional .onnxruntime.proto.MapInt64ToString map_int64_to_string = 5;
inline bool TraditionalMLData::_internal_has_map_int64_to_string() const {
  return values_case() == kMapInt64ToString;
}
inline bool TraditionalMLData::has_map_int64_to_string() const {
  return _internal_has_map_int64_to_string();
}
inline void TraditionalMLData::set_has_map_int64_to_string() {
  _oneof_case_[0] = kMapInt64ToString;
}
inline void TraditionalMLData::clear_map_int64_to_string() {
  if (_internal_has_map_int64_to_string()) {
    delete values_.map_int64_to_string_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::MapInt64ToString* TraditionalMLData::release_map_int64_to_string() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.map_int64_to_string)
  if (_internal_has_map_int64_to_string()) {
    clear_has_values();
      ::onnxruntime::proto::MapInt64ToString* temp = values_.map_int64_to_string_;
    values_.map_int64_to_string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::MapInt64ToString& TraditionalMLData::_internal_map_int64_to_string() const {
  return _internal_has_map_int64_to_string()
      ? *values_.map_int64_to_string_
      : *reinterpret_cast< ::onnxruntime::proto::MapInt64ToString*>(&::onnxruntime::proto::_MapInt64ToString_default_instance_);
}
inline const ::onnxruntime::proto::MapInt64ToString& TraditionalMLData::map_int64_to_string() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.map_int64_to_string)
  return _internal_map_int64_to_string();
}
inline ::onnxruntime::proto::MapInt64ToString* TraditionalMLData::_internal_mutable_map_int64_to_string() {
  if (!_internal_has_map_int64_to_string()) {
    clear_values();
    set_has_map_int64_to_string();
    values_.map_int64_to_string_ = CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToString >(
        GetArenaNoVirtual());
  }
  return values_.map_int64_to_string_;
}
inline ::onnxruntime::proto::MapInt64ToString* TraditionalMLData::mutable_map_int64_to_string() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.map_int64_to_string)
  return _internal_mutable_map_int64_to_string();
}

// optional .onnxruntime.proto.MapInt64ToInt64 map_int64_to_int64 = 6;
inline bool TraditionalMLData::_internal_has_map_int64_to_int64() const {
  return values_case() == kMapInt64ToInt64;
}
inline bool TraditionalMLData::has_map_int64_to_int64() const {
  return _internal_has_map_int64_to_int64();
}
inline void TraditionalMLData::set_has_map_int64_to_int64() {
  _oneof_case_[0] = kMapInt64ToInt64;
}
inline void TraditionalMLData::clear_map_int64_to_int64() {
  if (_internal_has_map_int64_to_int64()) {
    delete values_.map_int64_to_int64_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::MapInt64ToInt64* TraditionalMLData::release_map_int64_to_int64() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.map_int64_to_int64)
  if (_internal_has_map_int64_to_int64()) {
    clear_has_values();
      ::onnxruntime::proto::MapInt64ToInt64* temp = values_.map_int64_to_int64_;
    values_.map_int64_to_int64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::MapInt64ToInt64& TraditionalMLData::_internal_map_int64_to_int64() const {
  return _internal_has_map_int64_to_int64()
      ? *values_.map_int64_to_int64_
      : *reinterpret_cast< ::onnxruntime::proto::MapInt64ToInt64*>(&::onnxruntime::proto::_MapInt64ToInt64_default_instance_);
}
inline const ::onnxruntime::proto::MapInt64ToInt64& TraditionalMLData::map_int64_to_int64() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.map_int64_to_int64)
  return _internal_map_int64_to_int64();
}
inline ::onnxruntime::proto::MapInt64ToInt64* TraditionalMLData::_internal_mutable_map_int64_to_int64() {
  if (!_internal_has_map_int64_to_int64()) {
    clear_values();
    set_has_map_int64_to_int64();
    values_.map_int64_to_int64_ = CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToInt64 >(
        GetArenaNoVirtual());
  }
  return values_.map_int64_to_int64_;
}
inline ::onnxruntime::proto::MapInt64ToInt64* TraditionalMLData::mutable_map_int64_to_int64() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.map_int64_to_int64)
  return _internal_mutable_map_int64_to_int64();
}

// optional .onnxruntime.proto.MapInt64ToFloat map_int64_to_float = 7;
inline bool TraditionalMLData::_internal_has_map_int64_to_float() const {
  return values_case() == kMapInt64ToFloat;
}
inline bool TraditionalMLData::has_map_int64_to_float() const {
  return _internal_has_map_int64_to_float();
}
inline void TraditionalMLData::set_has_map_int64_to_float() {
  _oneof_case_[0] = kMapInt64ToFloat;
}
inline void TraditionalMLData::clear_map_int64_to_float() {
  if (_internal_has_map_int64_to_float()) {
    delete values_.map_int64_to_float_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::MapInt64ToFloat* TraditionalMLData::release_map_int64_to_float() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.map_int64_to_float)
  if (_internal_has_map_int64_to_float()) {
    clear_has_values();
      ::onnxruntime::proto::MapInt64ToFloat* temp = values_.map_int64_to_float_;
    values_.map_int64_to_float_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::MapInt64ToFloat& TraditionalMLData::_internal_map_int64_to_float() const {
  return _internal_has_map_int64_to_float()
      ? *values_.map_int64_to_float_
      : *reinterpret_cast< ::onnxruntime::proto::MapInt64ToFloat*>(&::onnxruntime::proto::_MapInt64ToFloat_default_instance_);
}
inline const ::onnxruntime::proto::MapInt64ToFloat& TraditionalMLData::map_int64_to_float() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.map_int64_to_float)
  return _internal_map_int64_to_float();
}
inline ::onnxruntime::proto::MapInt64ToFloat* TraditionalMLData::_internal_mutable_map_int64_to_float() {
  if (!_internal_has_map_int64_to_float()) {
    clear_values();
    set_has_map_int64_to_float();
    values_.map_int64_to_float_ = CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToFloat >(
        GetArenaNoVirtual());
  }
  return values_.map_int64_to_float_;
}
inline ::onnxruntime::proto::MapInt64ToFloat* TraditionalMLData::mutable_map_int64_to_float() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.map_int64_to_float)
  return _internal_mutable_map_int64_to_float();
}

// optional .onnxruntime.proto.MapInt64ToDouble map_int64_to_double = 8;
inline bool TraditionalMLData::_internal_has_map_int64_to_double() const {
  return values_case() == kMapInt64ToDouble;
}
inline bool TraditionalMLData::has_map_int64_to_double() const {
  return _internal_has_map_int64_to_double();
}
inline void TraditionalMLData::set_has_map_int64_to_double() {
  _oneof_case_[0] = kMapInt64ToDouble;
}
inline void TraditionalMLData::clear_map_int64_to_double() {
  if (_internal_has_map_int64_to_double()) {
    delete values_.map_int64_to_double_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::MapInt64ToDouble* TraditionalMLData::release_map_int64_to_double() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.map_int64_to_double)
  if (_internal_has_map_int64_to_double()) {
    clear_has_values();
      ::onnxruntime::proto::MapInt64ToDouble* temp = values_.map_int64_to_double_;
    values_.map_int64_to_double_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::MapInt64ToDouble& TraditionalMLData::_internal_map_int64_to_double() const {
  return _internal_has_map_int64_to_double()
      ? *values_.map_int64_to_double_
      : *reinterpret_cast< ::onnxruntime::proto::MapInt64ToDouble*>(&::onnxruntime::proto::_MapInt64ToDouble_default_instance_);
}
inline const ::onnxruntime::proto::MapInt64ToDouble& TraditionalMLData::map_int64_to_double() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.map_int64_to_double)
  return _internal_map_int64_to_double();
}
inline ::onnxruntime::proto::MapInt64ToDouble* TraditionalMLData::_internal_mutable_map_int64_to_double() {
  if (!_internal_has_map_int64_to_double()) {
    clear_values();
    set_has_map_int64_to_double();
    values_.map_int64_to_double_ = CreateMaybeMessage< ::onnxruntime::proto::MapInt64ToDouble >(
        GetArenaNoVirtual());
  }
  return values_.map_int64_to_double_;
}
inline ::onnxruntime::proto::MapInt64ToDouble* TraditionalMLData::mutable_map_int64_to_double() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.map_int64_to_double)
  return _internal_mutable_map_int64_to_double();
}

// optional .onnxruntime.proto.VectorString vector_string = 9;
inline bool TraditionalMLData::_internal_has_vector_string() const {
  return values_case() == kVectorString;
}
inline bool TraditionalMLData::has_vector_string() const {
  return _internal_has_vector_string();
}
inline void TraditionalMLData::set_has_vector_string() {
  _oneof_case_[0] = kVectorString;
}
inline void TraditionalMLData::clear_vector_string() {
  if (_internal_has_vector_string()) {
    delete values_.vector_string_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::VectorString* TraditionalMLData::release_vector_string() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.vector_string)
  if (_internal_has_vector_string()) {
    clear_has_values();
      ::onnxruntime::proto::VectorString* temp = values_.vector_string_;
    values_.vector_string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::VectorString& TraditionalMLData::_internal_vector_string() const {
  return _internal_has_vector_string()
      ? *values_.vector_string_
      : *reinterpret_cast< ::onnxruntime::proto::VectorString*>(&::onnxruntime::proto::_VectorString_default_instance_);
}
inline const ::onnxruntime::proto::VectorString& TraditionalMLData::vector_string() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.vector_string)
  return _internal_vector_string();
}
inline ::onnxruntime::proto::VectorString* TraditionalMLData::_internal_mutable_vector_string() {
  if (!_internal_has_vector_string()) {
    clear_values();
    set_has_vector_string();
    values_.vector_string_ = CreateMaybeMessage< ::onnxruntime::proto::VectorString >(
        GetArenaNoVirtual());
  }
  return values_.vector_string_;
}
inline ::onnxruntime::proto::VectorString* TraditionalMLData::mutable_vector_string() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.vector_string)
  return _internal_mutable_vector_string();
}

// optional .onnxruntime.proto.VectorFloat vector_float = 10;
inline bool TraditionalMLData::_internal_has_vector_float() const {
  return values_case() == kVectorFloat;
}
inline bool TraditionalMLData::has_vector_float() const {
  return _internal_has_vector_float();
}
inline void TraditionalMLData::set_has_vector_float() {
  _oneof_case_[0] = kVectorFloat;
}
inline void TraditionalMLData::clear_vector_float() {
  if (_internal_has_vector_float()) {
    delete values_.vector_float_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::VectorFloat* TraditionalMLData::release_vector_float() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.vector_float)
  if (_internal_has_vector_float()) {
    clear_has_values();
      ::onnxruntime::proto::VectorFloat* temp = values_.vector_float_;
    values_.vector_float_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::VectorFloat& TraditionalMLData::_internal_vector_float() const {
  return _internal_has_vector_float()
      ? *values_.vector_float_
      : *reinterpret_cast< ::onnxruntime::proto::VectorFloat*>(&::onnxruntime::proto::_VectorFloat_default_instance_);
}
inline const ::onnxruntime::proto::VectorFloat& TraditionalMLData::vector_float() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.vector_float)
  return _internal_vector_float();
}
inline ::onnxruntime::proto::VectorFloat* TraditionalMLData::_internal_mutable_vector_float() {
  if (!_internal_has_vector_float()) {
    clear_values();
    set_has_vector_float();
    values_.vector_float_ = CreateMaybeMessage< ::onnxruntime::proto::VectorFloat >(
        GetArenaNoVirtual());
  }
  return values_.vector_float_;
}
inline ::onnxruntime::proto::VectorFloat* TraditionalMLData::mutable_vector_float() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.vector_float)
  return _internal_mutable_vector_float();
}

// optional .onnxruntime.proto.VectorInt64 vector_int64 = 11;
inline bool TraditionalMLData::_internal_has_vector_int64() const {
  return values_case() == kVectorInt64;
}
inline bool TraditionalMLData::has_vector_int64() const {
  return _internal_has_vector_int64();
}
inline void TraditionalMLData::set_has_vector_int64() {
  _oneof_case_[0] = kVectorInt64;
}
inline void TraditionalMLData::clear_vector_int64() {
  if (_internal_has_vector_int64()) {
    delete values_.vector_int64_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::VectorInt64* TraditionalMLData::release_vector_int64() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.vector_int64)
  if (_internal_has_vector_int64()) {
    clear_has_values();
      ::onnxruntime::proto::VectorInt64* temp = values_.vector_int64_;
    values_.vector_int64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::VectorInt64& TraditionalMLData::_internal_vector_int64() const {
  return _internal_has_vector_int64()
      ? *values_.vector_int64_
      : *reinterpret_cast< ::onnxruntime::proto::VectorInt64*>(&::onnxruntime::proto::_VectorInt64_default_instance_);
}
inline const ::onnxruntime::proto::VectorInt64& TraditionalMLData::vector_int64() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.vector_int64)
  return _internal_vector_int64();
}
inline ::onnxruntime::proto::VectorInt64* TraditionalMLData::_internal_mutable_vector_int64() {
  if (!_internal_has_vector_int64()) {
    clear_values();
    set_has_vector_int64();
    values_.vector_int64_ = CreateMaybeMessage< ::onnxruntime::proto::VectorInt64 >(
        GetArenaNoVirtual());
  }
  return values_.vector_int64_;
}
inline ::onnxruntime::proto::VectorInt64* TraditionalMLData::mutable_vector_int64() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.vector_int64)
  return _internal_mutable_vector_int64();
}

// optional .onnxruntime.proto.VectorDouble vector_double = 12;
inline bool TraditionalMLData::_internal_has_vector_double() const {
  return values_case() == kVectorDouble;
}
inline bool TraditionalMLData::has_vector_double() const {
  return _internal_has_vector_double();
}
inline void TraditionalMLData::set_has_vector_double() {
  _oneof_case_[0] = kVectorDouble;
}
inline void TraditionalMLData::clear_vector_double() {
  if (_internal_has_vector_double()) {
    delete values_.vector_double_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::VectorDouble* TraditionalMLData::release_vector_double() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.vector_double)
  if (_internal_has_vector_double()) {
    clear_has_values();
      ::onnxruntime::proto::VectorDouble* temp = values_.vector_double_;
    values_.vector_double_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::VectorDouble& TraditionalMLData::_internal_vector_double() const {
  return _internal_has_vector_double()
      ? *values_.vector_double_
      : *reinterpret_cast< ::onnxruntime::proto::VectorDouble*>(&::onnxruntime::proto::_VectorDouble_default_instance_);
}
inline const ::onnxruntime::proto::VectorDouble& TraditionalMLData::vector_double() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.vector_double)
  return _internal_vector_double();
}
inline ::onnxruntime::proto::VectorDouble* TraditionalMLData::_internal_mutable_vector_double() {
  if (!_internal_has_vector_double()) {
    clear_values();
    set_has_vector_double();
    values_.vector_double_ = CreateMaybeMessage< ::onnxruntime::proto::VectorDouble >(
        GetArenaNoVirtual());
  }
  return values_.vector_double_;
}
inline ::onnxruntime::proto::VectorDouble* TraditionalMLData::mutable_vector_double() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.vector_double)
  return _internal_mutable_vector_double();
}

// optional .onnxruntime.proto.VectorMapStringToFloat vector_map_string_to_float = 13;
inline bool TraditionalMLData::_internal_has_vector_map_string_to_float() const {
  return values_case() == kVectorMapStringToFloat;
}
inline bool TraditionalMLData::has_vector_map_string_to_float() const {
  return _internal_has_vector_map_string_to_float();
}
inline void TraditionalMLData::set_has_vector_map_string_to_float() {
  _oneof_case_[0] = kVectorMapStringToFloat;
}
inline void TraditionalMLData::clear_vector_map_string_to_float() {
  if (_internal_has_vector_map_string_to_float()) {
    delete values_.vector_map_string_to_float_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::VectorMapStringToFloat* TraditionalMLData::release_vector_map_string_to_float() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.vector_map_string_to_float)
  if (_internal_has_vector_map_string_to_float()) {
    clear_has_values();
      ::onnxruntime::proto::VectorMapStringToFloat* temp = values_.vector_map_string_to_float_;
    values_.vector_map_string_to_float_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::VectorMapStringToFloat& TraditionalMLData::_internal_vector_map_string_to_float() const {
  return _internal_has_vector_map_string_to_float()
      ? *values_.vector_map_string_to_float_
      : *reinterpret_cast< ::onnxruntime::proto::VectorMapStringToFloat*>(&::onnxruntime::proto::_VectorMapStringToFloat_default_instance_);
}
inline const ::onnxruntime::proto::VectorMapStringToFloat& TraditionalMLData::vector_map_string_to_float() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.vector_map_string_to_float)
  return _internal_vector_map_string_to_float();
}
inline ::onnxruntime::proto::VectorMapStringToFloat* TraditionalMLData::_internal_mutable_vector_map_string_to_float() {
  if (!_internal_has_vector_map_string_to_float()) {
    clear_values();
    set_has_vector_map_string_to_float();
    values_.vector_map_string_to_float_ = CreateMaybeMessage< ::onnxruntime::proto::VectorMapStringToFloat >(
        GetArenaNoVirtual());
  }
  return values_.vector_map_string_to_float_;
}
inline ::onnxruntime::proto::VectorMapStringToFloat* TraditionalMLData::mutable_vector_map_string_to_float() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.vector_map_string_to_float)
  return _internal_mutable_vector_map_string_to_float();
}

// optional .onnxruntime.proto.VectorMapInt64ToFloat vector_map_int64_to_float = 14;
inline bool TraditionalMLData::_internal_has_vector_map_int64_to_float() const {
  return values_case() == kVectorMapInt64ToFloat;
}
inline bool TraditionalMLData::has_vector_map_int64_to_float() const {
  return _internal_has_vector_map_int64_to_float();
}
inline void TraditionalMLData::set_has_vector_map_int64_to_float() {
  _oneof_case_[0] = kVectorMapInt64ToFloat;
}
inline void TraditionalMLData::clear_vector_map_int64_to_float() {
  if (_internal_has_vector_map_int64_to_float()) {
    delete values_.vector_map_int64_to_float_;
    clear_has_values();
  }
}
inline ::onnxruntime::proto::VectorMapInt64ToFloat* TraditionalMLData::release_vector_map_int64_to_float() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.vector_map_int64_to_float)
  if (_internal_has_vector_map_int64_to_float()) {
    clear_has_values();
      ::onnxruntime::proto::VectorMapInt64ToFloat* temp = values_.vector_map_int64_to_float_;
    values_.vector_map_int64_to_float_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnxruntime::proto::VectorMapInt64ToFloat& TraditionalMLData::_internal_vector_map_int64_to_float() const {
  return _internal_has_vector_map_int64_to_float()
      ? *values_.vector_map_int64_to_float_
      : *reinterpret_cast< ::onnxruntime::proto::VectorMapInt64ToFloat*>(&::onnxruntime::proto::_VectorMapInt64ToFloat_default_instance_);
}
inline const ::onnxruntime::proto::VectorMapInt64ToFloat& TraditionalMLData::vector_map_int64_to_float() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.vector_map_int64_to_float)
  return _internal_vector_map_int64_to_float();
}
inline ::onnxruntime::proto::VectorMapInt64ToFloat* TraditionalMLData::_internal_mutable_vector_map_int64_to_float() {
  if (!_internal_has_vector_map_int64_to_float()) {
    clear_values();
    set_has_vector_map_int64_to_float();
    values_.vector_map_int64_to_float_ = CreateMaybeMessage< ::onnxruntime::proto::VectorMapInt64ToFloat >(
        GetArenaNoVirtual());
  }
  return values_.vector_map_int64_to_float_;
}
inline ::onnxruntime::proto::VectorMapInt64ToFloat* TraditionalMLData::mutable_vector_map_int64_to_float() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.vector_map_int64_to_float)
  return _internal_mutable_vector_map_int64_to_float();
}

// optional .onnx.TensorProto tensor = 16;
inline bool TraditionalMLData::_internal_has_tensor() const {
  return values_case() == kTensor;
}
inline bool TraditionalMLData::has_tensor() const {
  return _internal_has_tensor();
}
inline void TraditionalMLData::set_has_tensor() {
  _oneof_case_[0] = kTensor;
}
inline ::onnx::TensorProto* TraditionalMLData::release_tensor() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.tensor)
  if (_internal_has_tensor()) {
    clear_has_values();
      ::onnx::TensorProto* temp = values_.tensor_;
    values_.tensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onnx::TensorProto& TraditionalMLData::_internal_tensor() const {
  return _internal_has_tensor()
      ? *values_.tensor_
      : *reinterpret_cast< ::onnx::TensorProto*>(&::onnx::_TensorProto_default_instance_);
}
inline const ::onnx::TensorProto& TraditionalMLData::tensor() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.tensor)
  return _internal_tensor();
}
inline ::onnx::TensorProto* TraditionalMLData::_internal_mutable_tensor() {
  if (!_internal_has_tensor()) {
    clear_values();
    set_has_tensor();
    values_.tensor_ = CreateMaybeMessage< ::onnx::TensorProto >(
        GetArenaNoVirtual());
  }
  return values_.tensor_;
}
inline ::onnx::TensorProto* TraditionalMLData::mutable_tensor() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.tensor)
  return _internal_mutable_tensor();
}

// optional string name = 15;
inline bool TraditionalMLData::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TraditionalMLData::has_name() const {
  return _internal_has_name();
}
inline void TraditionalMLData::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TraditionalMLData::name() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.name)
  return _internal_name();
}
inline void TraditionalMLData::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:onnxruntime.proto.TraditionalMLData.name)
}
inline std::string* TraditionalMLData::mutable_name() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.name)
  return _internal_mutable_name();
}
inline const std::string& TraditionalMLData::_internal_name() const {
  return name_.GetNoArena();
}
inline void TraditionalMLData::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TraditionalMLData::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:onnxruntime.proto.TraditionalMLData.name)
}
inline void TraditionalMLData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:onnxruntime.proto.TraditionalMLData.name)
}
inline void TraditionalMLData::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:onnxruntime.proto.TraditionalMLData.name)
}
inline std::string* TraditionalMLData::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TraditionalMLData::release_name() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TraditionalMLData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.name)
}

// optional string debug_info = 17;
inline bool TraditionalMLData::_internal_has_debug_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TraditionalMLData::has_debug_info() const {
  return _internal_has_debug_info();
}
inline void TraditionalMLData::clear_debug_info() {
  debug_info_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TraditionalMLData::debug_info() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TraditionalMLData.debug_info)
  return _internal_debug_info();
}
inline void TraditionalMLData::set_debug_info(const std::string& value) {
  _internal_set_debug_info(value);
  // @@protoc_insertion_point(field_set:onnxruntime.proto.TraditionalMLData.debug_info)
}
inline std::string* TraditionalMLData::mutable_debug_info() {
  // @@protoc_insertion_point(field_mutable:onnxruntime.proto.TraditionalMLData.debug_info)
  return _internal_mutable_debug_info();
}
inline const std::string& TraditionalMLData::_internal_debug_info() const {
  return debug_info_.GetNoArena();
}
inline void TraditionalMLData::_internal_set_debug_info(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  debug_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TraditionalMLData::set_debug_info(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  debug_info_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:onnxruntime.proto.TraditionalMLData.debug_info)
}
inline void TraditionalMLData::set_debug_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  debug_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:onnxruntime.proto.TraditionalMLData.debug_info)
}
inline void TraditionalMLData::set_debug_info(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  debug_info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:onnxruntime.proto.TraditionalMLData.debug_info)
}
inline std::string* TraditionalMLData::_internal_mutable_debug_info() {
  _has_bits_[0] |= 0x00000002u;
  return debug_info_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TraditionalMLData::release_debug_info() {
  // @@protoc_insertion_point(field_release:onnxruntime.proto.TraditionalMLData.debug_info)
  if (!_internal_has_debug_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return debug_info_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TraditionalMLData::set_allocated_debug_info(std::string* debug_info) {
  if (debug_info != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  debug_info_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), debug_info);
  // @@protoc_insertion_point(field_set_allocated:onnxruntime.proto.TraditionalMLData.debug_info)
}

inline bool TraditionalMLData::has_values() const {
  return values_case() != VALUES_NOT_SET;
}
inline void TraditionalMLData::clear_has_values() {
  _oneof_case_[0] = VALUES_NOT_SET;
}
inline TraditionalMLData::ValuesCase TraditionalMLData::values_case() const {
  return TraditionalMLData::ValuesCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TestCaseConfig

// optional double per_sample_tolerance = 1;
inline bool TestCaseConfig::_internal_has_per_sample_tolerance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestCaseConfig::has_per_sample_tolerance() const {
  return _internal_has_per_sample_tolerance();
}
inline void TestCaseConfig::clear_per_sample_tolerance() {
  per_sample_tolerance_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double TestCaseConfig::_internal_per_sample_tolerance() const {
  return per_sample_tolerance_;
}
inline double TestCaseConfig::per_sample_tolerance() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TestCaseConfig.per_sample_tolerance)
  return _internal_per_sample_tolerance();
}
inline void TestCaseConfig::_internal_set_per_sample_tolerance(double value) {
  _has_bits_[0] |= 0x00000001u;
  per_sample_tolerance_ = value;
}
inline void TestCaseConfig::set_per_sample_tolerance(double value) {
  _internal_set_per_sample_tolerance(value);
  // @@protoc_insertion_point(field_set:onnxruntime.proto.TestCaseConfig.per_sample_tolerance)
}

// optional double relative_per_sample_tolerance = 2;
inline bool TestCaseConfig::_internal_has_relative_per_sample_tolerance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestCaseConfig::has_relative_per_sample_tolerance() const {
  return _internal_has_relative_per_sample_tolerance();
}
inline void TestCaseConfig::clear_relative_per_sample_tolerance() {
  relative_per_sample_tolerance_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double TestCaseConfig::_internal_relative_per_sample_tolerance() const {
  return relative_per_sample_tolerance_;
}
inline double TestCaseConfig::relative_per_sample_tolerance() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TestCaseConfig.relative_per_sample_tolerance)
  return _internal_relative_per_sample_tolerance();
}
inline void TestCaseConfig::_internal_set_relative_per_sample_tolerance(double value) {
  _has_bits_[0] |= 0x00000002u;
  relative_per_sample_tolerance_ = value;
}
inline void TestCaseConfig::set_relative_per_sample_tolerance(double value) {
  _internal_set_relative_per_sample_tolerance(value);
  // @@protoc_insertion_point(field_set:onnxruntime.proto.TestCaseConfig.relative_per_sample_tolerance)
}

// optional bool post_processing = 3;
inline bool TestCaseConfig::_internal_has_post_processing() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TestCaseConfig::has_post_processing() const {
  return _internal_has_post_processing();
}
inline void TestCaseConfig::clear_post_processing() {
  post_processing_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool TestCaseConfig::_internal_post_processing() const {
  return post_processing_;
}
inline bool TestCaseConfig::post_processing() const {
  // @@protoc_insertion_point(field_get:onnxruntime.proto.TestCaseConfig.post_processing)
  return _internal_post_processing();
}
inline void TestCaseConfig::_internal_set_post_processing(bool value) {
  _has_bits_[0] |= 0x00000004u;
  post_processing_ = value;
}
inline void TestCaseConfig::set_post_processing(bool value) {
  _internal_set_post_processing(value);
  // @@protoc_insertion_point(field_set:onnxruntime.proto.TestCaseConfig.post_processing)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace onnxruntime

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tml_2eproto
